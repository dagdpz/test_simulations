function testsim_cluster_perm_vs_shuffled_claude
% mainly generated by Claude 3.5 Sonnet


% Example usage:
% Generate sample data
time_points = 50;
frequencies = 50;
n_permutations = 1000;
level_of_noise = 1;
alpha = 0.05;
cluster_thresh = 0.05;
ci_thresh = 0.95;

rng(1); % comment if you don't want the same seed

% Create actual signal (example with a simulated effect)
actual_tf = level_of_noise*randn(time_points, frequencies);

% Add effects
effect_strength  = [-2 3 4 5];
effect_time = [3 8; 10 20; 25 30; 40 47];
effect_freq = [3 8; 10 20; 15 25; 30 33];

for i = 1:length(effect_strength)
        actual_tf(effect_time(i,1):effect_time(i,2), effect_freq(i,1):effect_freq(i,2)) = ...
        actual_tf(effect_time(i,1):effect_time(i,2), effect_freq(i,1):effect_freq(i,2)) + effect_strength(i);
end

% actual_tf(40:60, 20:30) = actual_tf(40:60, 20:30) + 5;  % Add effect

% Create shuffled data
shuffled_tf = level_of_noise*randn(time_points, frequencies, n_permutations);

null_mean = mean(shuffled_tf, 3);
null_std = std(shuffled_tf, 0, 3);

% Run permutation test
% [clusters, cluster_stats, p_values, significance_map] = tfClusterPermTest(actual_tf, shuffled_tf, alpha, cluster_thresh);
% [clusters, cluster_stats, p_values, significance_map] = tfClusterPermTestWithMeanStd(actual_tf, null_mean, null_std, alpha, cluster_thresh);
[clusters, cluster_stats, p_values, significance_map] = tfClusterPermTestWithCI(actual_tf, shuffled_tf, alpha, ci_thresh);



% Visualization
figure('Position', [100 100 1200 400]);

% Get common color limits for both plots
cmin = min(min(actual_tf(:)), min(null_mean(:)));
cmax = max(max(actual_tf(:)), max(null_mean(:)));

% Plot mean shuffled data
subplot(1,2,1);
imagesc(null_mean);
colorbar;
title('Mean of Shuffled Data');
ylabel('Frequency');
xlabel('Time');
caxis([cmin cmax]);

% Plot actual data with transparency for non-significant regions
subplot(1,2,2);
h_all = imagesc(actual_tf);

% Apply 50% transparency to nonsignificant bins by setting their color to a pale shade
alpha_data = 0.5 * ones(size(actual_tf));  % Initialize all bins with 50% transparency
alpha_data(significance_map) = 1;        % Keep significant clusters opaque
set(h_all, 'AlphaData', alpha_data);
plotRegionBoundaries(alpha_data==1);

colorbar;
title('Actual Data (Î±=0.5 for non-significant)');
ylabel('Frequency');
xlabel('Time');
caxis([cmin cmax]);
hold off;

% Print results
fprintf('Number of clusters found: %d\n', length(clusters));
for i = 1:length(clusters)
    % fprintf('Cluster %d: stat = %.2f, p = %.3f\n', i, cluster_stats(i), p_values(i));
end




function [clusters, cluster_stats, p_values, significance_map] = tfClusterPermTest(actual_tf, shuffled_tf, alpha, cluster_thresh)
% Time-frequency cluster-based permutation test
%
% 1. Takes actual signal and shuffled versions as input
% 2. Computes t-statistics comparing actual signal to null distribution
% 3. Identifies clusters of significant points using connected components
% 4. Computes cluster-level statistics by summing t-values within clusters
% 5. Builds null distribution through permutations
% 6. Computes p-values for each cluster
% 7. Returns significant clusters and creates a significance map

% Inputs:
% actual_tf: 2D matrix [time x frequency] of actual signal
% shuffled_tf: 3D matrix [time x frequency x n_permutations] of shuffled data
% alpha: significance level (e.g., 0.05)
% cluster_thresh: threshold for initial clustering (e.g., 0.05)
%
% Outputs:
% clusters: cell array of cluster indices
% cluster_stats: statistics for each cluster
% p_values: p-value for each cluster
% significance_map: binary map of significant clusters

% Get dimensions
[n_time, n_freq, n_perms] = size(shuffled_tf);

% Step 1: Compute t-statistics at each point
% Calculate mean and std of null distribution at each point
null_mean = mean(shuffled_tf, 3);
null_std = std(shuffled_tf, 0, 3);

% Compute t-statistic map
t_map = (actual_tf - null_mean) ./ (null_std + eps);

% Step 2: Threshold the t-statistics separately for positive and negative values
pos_thresh = t_map > tinv(1-cluster_thresh/2, n_perms-1);
neg_thresh = t_map < tinv(cluster_thresh/2, n_perms-1);

% % Fill holes in positive and negative threshold maps
% pos_thresh_filled = imfill(pos_thresh, 'holes');
% neg_thresh_filled = imfill(neg_thresh, 'holes');

% % Find clusters using filled maps
% pos_clusters = bwconncomp(pos_thresh_filled, 8);
% neg_clusters = bwconncomp(neg_thresh_filled, 8);

% Step 3: Find clusters separately for positive and negative thresholded maps
pos_clusters = bwconncomp(pos_thresh, 8);
neg_clusters = bwconncomp(neg_thresh, 8);


% Combine positive and negative clusters
n_pos_clusters = pos_clusters.NumObjects;
n_neg_clusters = neg_clusters.NumObjects;
n_clusters = n_pos_clusters + n_neg_clusters;

% Initialize outputs
clusters = cell(1, n_clusters);
cluster_stats = zeros(1, n_clusters);
p_values = ones(1, n_clusters);
significance_map = false(n_time, n_freq);

if n_clusters == 0
    return;
end

% Store all clusters (positive first, then negative)
clusters(1:n_pos_clusters) = pos_clusters.PixelIdxList;
clusters(n_pos_clusters+1:end) = neg_clusters.PixelIdxList;

% Step 4: Compute cluster statistics (keeping sign information)
for i = 1:n_clusters
    if i <= n_pos_clusters
        % For positive clusters, sum the positive t-values
        cluster_stats(i) = sum(t_map(clusters{i}));
    else
        % For negative clusters, sum the negative t-values
        cluster_stats(i) = sum(t_map(clusters{i}));
    end
end

% Step 5: Build null distribution of cluster statistics
null_max_stats = zeros(1, n_perms);
null_min_stats = zeros(1, n_perms);


for p = 1:n_perms
    % Compute t-statistics for this permutation
    perm_t_map = (shuffled_tf(:,:,p) - null_mean) ./ (null_std + eps);
    
    % Threshold and find clusters for both positive and negative
    perm_pos_thresh = perm_t_map > tinv(1-cluster_thresh/2, n_perms-1);
    perm_neg_thresh = perm_t_map < tinv(cluster_thresh/2, n_perms-1);
    
    perm_pos_clusters = bwconncomp(perm_pos_thresh, 8);
    perm_neg_clusters = bwconncomp(perm_neg_thresh, 8);
    
    % Compute statistics for positive clusters
    max_pos_stat = 0;
    if perm_pos_clusters.NumObjects > 0
        pos_stats = zeros(1, perm_pos_clusters.NumObjects);
        for c = 1:perm_pos_clusters.NumObjects
            pos_stats(c) = sum(perm_t_map(perm_pos_clusters.PixelIdxList{c}));
        end
        max_pos_stat = max(pos_stats);
    end
    
    % Compute statistics for negative clusters
    min_neg_stat = 0;
    if perm_neg_clusters.NumObjects > 0
        neg_stats = zeros(1, perm_neg_clusters.NumObjects);
        for c = 1:perm_neg_clusters.NumObjects
            neg_stats(c) = sum(perm_t_map(perm_neg_clusters.PixelIdxList{c}));
        end
        min_neg_stat = min(neg_stats);
    end
    
    null_max_stats(p) = max_pos_stat;
    null_min_stats(p) = min_neg_stat;
end

% Step 6: Compute p-values separately for positive and negative clusters
for i = 1:n_clusters
    if i <= n_pos_clusters
        % For positive clusters, compare with null_max_stats
        p_values(i) = mean(null_max_stats >= cluster_stats(i));
    else
        % For negative clusters, compare with null_min_stats
        p_values(i) = mean(null_min_stats <= cluster_stats(i));
    end
end

% Create significance map
for i = 1:n_clusters
    if p_values(i) < alpha
        significance_map(clusters{i}) = true;
    end
end



function [clusters, cluster_stats, p_values, significance_map] = tfClusterPermTestWithMeanStd(actual_tf, null_mean, null_std, alpha, cluster_thresh)
% Time-frequency cluster-based permutation test using mean and std of permuted data
%
% The function is renamed to tfClusterPermTestWithMeanStd to reflect the new input parameters.
% Instead of taking the full 3D permuted data matrix, the function now takes the 2D mean and standard deviation of the permuted data as input.
% The null distribution of cluster-level statistics is generated using a parametric approach, where random t-maps are created based on the provided null mean and standard deviation.
% The p-values are computed by comparing the actual cluster statistics to the null distribution.
%
% Inputs:
% actual_tf: 2D matrix [time x frequency] of actual signal
% null_mean: 2D matrix [time x frequency] of mean of permuted data
% null_std: 2D matrix [time x frequency] of standard deviation of permuted data
% alpha: significance level (e.g., 0.05)
% cluster_thresh: threshold for initial clustering (e.g., 0.05)
%
% Outputs:
% clusters: cell array of cluster indices (combining positive and negative clusters)
% cluster_stats: statistics for each cluster
% p_values: p-values for each cluster
% significance_map: binary map of significant clusters

% Get dimensions
[n_time, n_freq] = size(actual_tf);

% Compute t-statistics at each point
t_map = (actual_tf - null_mean) ./ (null_std + eps);

% Threshold the t-statistics
pos_thresh_map = t_map > tinv(1-cluster_thresh/2, inf);
neg_thresh_map = t_map < -tinv(1-cluster_thresh/2, inf);

% Find clusters in thresholded maps
pos_connected_clusters = bwconncomp(pos_thresh_map, 8);  % 8-connected neighborhoods
neg_connected_clusters = bwconncomp(neg_thresh_map, 8);

% Initialize outputs
n_pos_clusters = pos_connected_clusters.NumObjects;
n_neg_clusters = neg_connected_clusters.NumObjects;
pos_clusters = pos_connected_clusters.PixelIdxList;
neg_clusters = neg_connected_clusters.PixelIdxList;

% Combine clusters
n_total_clusters = n_pos_clusters + n_neg_clusters;
clusters = cell(1, n_total_clusters);
cluster_stats = zeros(1, n_total_clusters);
p_values = ones(1, n_total_clusters);

% Copy positive clusters and their statistics
for i = 1:n_pos_clusters
    clusters{i} = pos_clusters{i};
    cluster_stats(i) = sum(t_map(pos_clusters{i}));
end

% Copy negative clusters and their statistics
for i = 1:n_neg_clusters
    clusters{i + n_pos_clusters} = neg_clusters{i};
    cluster_stats(i + n_pos_clusters) = sum(t_map(neg_clusters{i}));
end

significance_map = false(n_time, n_freq);

if n_total_clusters == 0
    return;
end

% Build null distribution of cluster statistics using parametric approach
num_perms = 10000;
% Generate random maps for all permutations at once
perm_maps = randn(n_time, n_freq, num_perms) .* null_std + null_mean;
pos_null_cluster_stats = zeros(1, num_perms);
neg_null_cluster_stats = zeros(1, num_perms);

% Process each permutation
for i = 1:num_perms
    curr_map = perm_maps(:,:,i);
    
    % Find positive clusters
    pos_perm_thresh_map = curr_map > tinv(1-cluster_thresh/2, inf);
    pos_perm_clusters = bwconncomp(pos_perm_thresh_map, 8);
    
    if pos_perm_clusters.NumObjects > 0
        pos_perm_cluster_stats = zeros(1, pos_perm_clusters.NumObjects);
        for c = 1:pos_perm_clusters.NumObjects
            pos_perm_cluster_stats(c) = sum(curr_map(pos_perm_clusters.PixelIdxList{c}));
        end
        pos_null_cluster_stats(i) = max(pos_perm_cluster_stats);
    end
    
    % Find negative clusters
    neg_perm_thresh_map = curr_map < -tinv(1-cluster_thresh/2, inf);
    neg_perm_clusters = bwconncomp(neg_perm_thresh_map, 8);
    
    if neg_perm_clusters.NumObjects > 0
        neg_perm_cluster_stats = zeros(1, neg_perm_clusters.NumObjects);
        for c = 1:neg_perm_clusters.NumObjects
            neg_perm_cluster_stats(c) = sum(curr_map(neg_perm_clusters.PixelIdxList{c}));
        end
        neg_null_cluster_stats(i) = min(neg_perm_cluster_stats);
    end
end

% Compute p-values
for i = 1:n_pos_clusters
    p_values(i) = mean(pos_null_cluster_stats >= cluster_stats(i));
end
for i = 1:n_neg_clusters
    p_values(i + n_pos_clusters) = mean(neg_null_cluster_stats <= cluster_stats(i + n_pos_clusters));
end

% Create significance map
for i = 1:n_total_clusters
    if p_values(i) < alpha
        significance_map(clusters{i}) = true;
    end
end

function [clusters, cluster_stats, p_values, significance_map] = tfClusterPermTestWithCI(actual_tf, shuffled_tf, alpha, ci_thresh)
% Time-frequency cluster-based permutation test using confidence intervals
%
% Inputs:
% actual_tf: 2D matrix [time x frequency] of actual signal
% shuffled_tf: 3D matrix [time x frequency x n_permutations] of shuffled data
% alpha: significance level (e.g., 0.05)
% ci_thresh: confidence interval level (e.g., 0.95)
%
% Outputs:
% clusters: cell array of cluster indices
% cluster_stats: statistics for each cluster
% p_values: p-value for each cluster
% significance_map: binary map of significant clusters

% Get dimensions
[n_time, n_freq, n_perms] = size(shuffled_tf);

% Compute null distribution stats
null_mean = mean(shuffled_tf, 3);
null_std = std(shuffled_tf, 0, 3);
null_lower = null_mean - tinv((1 + ci_thresh) / 2, n_perms-1) * null_std;
null_upper = null_mean + tinv((1 + ci_thresh) / 2, n_perms-1) * null_std;

% Find positive and negative clusters separately
pos_cluster_mask = actual_tf > null_upper;
neg_cluster_mask = actual_tf < null_lower;

% Label clusters independently for positive and negative masks
pos_clusters = bwconncomp(pos_cluster_mask, 8);
neg_clusters = bwconncomp(neg_cluster_mask, 8);

% Combine positive and negative clusters
clusters = [pos_clusters.PixelIdxList, neg_clusters.PixelIdxList];
n_clusters = numel(clusters);

% Initialize outputs
cluster_stats = zeros(1, n_clusters);
p_values = ones(1, n_clusters);
significance_map = false(n_time, n_freq);

if n_clusters == 0
    return;
end

% Compute cluster-level statistics for positive clusters
for i = 1:n_clusters
    cluster_indices = clusters{i};
    
    % Calculate cluster statistic based on sign
    if i <= numel(pos_clusters.PixelIdxList)
        % Positive cluster statistic
        cluster_stats(i) = sum(actual_tf(cluster_indices));
    else
        % Negative cluster statistic
        cluster_stats(i) = sum(-actual_tf(cluster_indices)); % flip sign for negative clusters
    end
end

% Compute p-values for each cluster
for i = 1:n_clusters
    % Observed cluster statistic
    observed_cluster_stat = cluster_stats(i);
    perm_cluster_stats = zeros(1, n_perms);

    % Calculate permuted statistics based on cluster indices
    for p = 1:n_perms
        perm_data = shuffled_tf(:,:,p);
        if i <= numel(pos_clusters.PixelIdxList)
            % Positive cluster: use positive threshold
            perm_cluster_stats(p) = sum(perm_data(clusters{i}));
        else
            % Negative cluster: use negative threshold
            perm_cluster_stats(p) = sum(-perm_data(clusters{i}));
        end
    end

    % P-value: proportion of permuted stats >= observed
    p_values(i) = mean(perm_cluster_stats >= observed_cluster_stat);
end

% Create significance map
for i = 1:n_clusters
    if p_values(i) < alpha
        significance_map(clusters{i}) = true;
    end
end

function [clusters, cluster_stats, p_values, significance_map] = tfClusterPermTestWithCI_(actual_tf, shuffled_tf, alpha, ci_thresh)
% Time-frequency cluster-based permutation test using confidence intervals
%
% The function is renamed to tfClusterPermTestWithCI to reflect the new approach.
% Instead of generating a null distribution of cluster statistics, the function computes the 95% confidence intervals for each time-frequency point based on the permuted data.
% The thresholding step checks which points in the actual data are outside the 95% confidence intervals of the permuted data.
% The cluster-level statistics are computed by summing the absolute values of the actual data within each cluster.
% The p-values are computed by checking how often the absolute value of the actual data within each cluster is greater than or equal to the absolute value of the upper or lower 95% confidence interval.
% The significance map is created based on the p-values and the specified alpha level.

% Inputs:
% actual_tf: 2D matrix [time x frequency] of actual signal
% shuffled_tf: 3D matrix [time x frequency x n_permutations] of shuffled data
% alpha: significance level (e.g., 0.05)
% ci_thresh: confidence interval level (e.g., 0.95)
%
% Outputs:
% clusters: cell array of cluster indices
% cluster_stats: statistics for each cluster
% p_values: p-value for each cluster
% significance_map: binary map of significant clusters

% Get dimensions
[n_time, n_freq, n_perms] = size(shuffled_tf);

% Compute null distribution stats
null_mean = mean(shuffled_tf, 3);
null_std = std(shuffled_tf, 0, 3);
null_lower = null_mean - tinv((1 + ci_thresh) / 2, n_perms-1) * null_std;
null_upper = null_mean + tinv((1 + ci_thresh) / 2, n_perms-1) * null_std;

% Find clusters where actual data is outside null distribution
thresh_map = (actual_tf < null_lower) | (actual_tf > null_upper);
connected_clusters = bwconncomp(thresh_map, 8);

% Initialize outputs
n_clusters = connected_clusters.NumObjects;
clusters = connected_clusters.PixelIdxList;
cluster_stats = zeros(1, n_clusters);
p_values = ones(1, n_clusters);
significance_map = false(n_time, n_freq);

if n_clusters == 0
    return;
end

% Compute cluster-level statistics
for i = 1:n_clusters
    cluster_stats(i) = sum(abs(actual_tf(clusters{i})));
end

% Compute p-values
for i = 1:n_clusters
    % Get the cluster statistic for observed data
    observed_cluster_stat = cluster_stats(i);
    
    % Calculate same cluster statistic for each permutation
    perm_cluster_stats = zeros(1, n_perms);
    for p = 1:n_perms
        perm_data = shuffled_tf(:,:,p);
        perm_cluster_stats(p) = sum(abs(perm_data(clusters{i})));
    end
    
    % P-value is proportion of permutation statistics >= observed
    p_values(i) = mean(perm_cluster_stats >= observed_cluster_stat);
end

% Create significance map
for i = 1:n_clusters
    if p_values(i) < alpha
        significance_map(clusters{i}) = true;
    end
end



function plotRegionBoundaries(matrix)
% Get matrix dimensions
[rows, cols] = size(matrix);

% Create figure and display binary matrix
% figure;
% imagesc(matrix);
% colormap([1 1 1; 0 0 1]); % White background, blue regions
% axis equal tight;
hold on;

% Create extended matrix with padding to help detect edges
padded = zeros(rows+2, cols+2);
padded(2:end-1, 2:end-1) = matrix;

% Initialize arrays to store line segments
x = [];
y = [];

% Scan for horizontal edges
for i = 1:rows
    for j = 1:cols
        if matrix(i,j) == 1
            % Check top edge
            if i == 1 || matrix(i-1,j) == 0
                x = [x, j-0.5, j+0.5, NaN];
                y = [y, i-0.5, i-0.5, NaN];
            end
            % Check bottom edge
            if i == rows || matrix(i+1,j) == 0
                x = [x, j-0.5, j+0.5, NaN];
                y = [y, i+0.5, i+0.5, NaN];
            end
        end
    end
end

% Scan for vertical edges
for j = 1:cols
    for i = 1:rows
        if matrix(i,j) == 1
            % Check left edge
            if j == 1 || matrix(i,j-1) == 0
                x = [x, j-0.5, j-0.5, NaN];
                y = [y, i-0.5, i+0.5, NaN];
            end
            % Check right edge
            if j == cols || matrix(i,j+1) == 0
                x = [x, j+0.5, j+0.5, NaN];
                y = [y, i-0.5, i+0.5, NaN];
            end
        end
    end
end

% Plot all edges at once
plot(x, y, 'k', 'LineWidth', 2);





