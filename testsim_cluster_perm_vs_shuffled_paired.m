function testsim_cluster_perm_vs_shuffled_paired
% this function runs a paired permutation test of original data vs shuffled data
% and visualizes the results
% mainly generated by Claude 3.5 Sonnet via Cursuor

% Generate sample data (vectorized)
time_points = 50;
frequencies = 50;
n_sites = 30;
level_of_noise = 1;

% Generate noise for all sites at once
actual_tf_sites = level_of_noise * randn(time_points, frequencies, n_sites);
shuffled_tf_sites = level_of_noise * randn(time_points, frequencies, n_sites);

% Add effects (vectorized)
effect_strength = [-2 3 4 5];
effect_time = [3 8; 10 20; 25 30; 40 47];
effect_freq = [3 8; 10 20; 15 25; 30 33];

% Generate site-specific random variations for all effects at once
site_variations = 0.2 * randn(length(effect_strength), n_sites);

for i = 1:length(effect_strength)
    % Add effect with variations to all sites at once
    time_idx = effect_time(i,1):effect_time(i,2);
    freq_idx = effect_freq(i,1):effect_freq(i,2);
    
    effect_matrix = reshape(effect_strength(i) + site_variations(i,:), ...
        [1, 1, n_sites]);
    actual_tf_sites(time_idx, freq_idx, :) = ...
        actual_tf_sites(time_idx, freq_idx, :) + ...
        repmat(effect_matrix, [length(time_idx), length(freq_idx), 1]);
end

% Run analysis
[clusters, cluster_stats, p_values, significance_map] = ...
    tfPairedClusterPermTest(actual_tf_sites, shuffled_tf_sites, 0.05, 0.05);

% Visualization (using efficient matrix operations)
figure('Position', [100 100 1200 400]);

mean_actual = mean(actual_tf_sites, 3);
mean_shuffled = mean(shuffled_tf_sites, 3);

% Get color limits using vectorized min/max
clims = [min(min(mean_actual(:)), min(mean_shuffled(:))), ...
    max(max(mean_actual(:)), max(mean_shuffled(:)))];

% Plot mean shuffled data
subplot(1,2,1);
imagesc(mean_shuffled);
colorbar;
title('Mean of Shuffled Data Across Sites');
ylabel('Frequency');
xlabel('Time');
caxis(clims);

% Plot mean actual data
subplot(1,2,2);
h_all = imagesc(mean_actual);

% Create alpha data matrix in one operation
alpha_data = 0.5 + 0.5 * significance_map;
set(h_all, 'AlphaData', alpha_data);

hold on;
plotRegionBoundaries(significance_map);

colorbar;
title('Mean Actual Data (Î±=0.5 for non-significant)');
ylabel('Frequency');
xlabel('Time');
caxis(clims);

% Print results
fprintf('Number of clusters found: %d\n', length(clusters));
% if ~isempty(clusters)
%     fprintf('Cluster statistics and p-values:\n');
%     disp([cluster_stats', p_values']);
% end

function [clusters, cluster_stats, p_values, significance_map] = tfPairedClusterPermTest(actual_tf_sites, shuffled_tf_sites, alpha, cluster_thresh)
% Vectorized paired time-frequency cluster-based permutation test across multiple sites
%
% Inputs:
% actual_tf_sites: 3D matrix [time x frequency x sites] of actual signals
% shuffled_tf_sites: 3D matrix [time x frequency x sites] of shuffled/control data
% alpha: significance level (e.g., 0.05)
% cluster_thresh: threshold for initial clustering (e.g., 0.05)
%
% Outputs:
% clusters: cell array of cluster indices
% cluster_stats: statistics for each cluster
% p_values: p-value for each cluster
% significance_map: binary map of significant clusters

% Get dimensions
[n_time, n_freq, n_sites] = size(actual_tf_sites);
n_perms = 1000;

% Initialize random number generator for reproducibility
rng('default');

% Step 1: Compute difference between conditions
diff_data = actual_tf_sites - shuffled_tf_sites;

% Compute original t-statistics
mean_diff = mean(diff_data, 3);
stderr_diff = std(diff_data, 0, 3) / sqrt(n_sites);
t_map = mean_diff ./ (stderr_diff + eps);
df = n_sites - 1;

% Step 2: Find clusters in original data
t_thresh_pos = tinv(1-cluster_thresh/2, df);
t_thresh_neg = tinv(cluster_thresh/2, df);

pos_thresh = t_map > t_thresh_pos;
neg_thresh = t_map < t_thresh_neg;

% Find clusters using connected components
pos_clusters = bwconncomp(pos_thresh, 8);
neg_clusters = bwconncomp(neg_thresh, 8);

% Combine positive and negative clusters
n_pos_clusters = pos_clusters.NumObjects;
n_neg_clusters = neg_clusters.NumObjects;
n_clusters = n_pos_clusters + n_neg_clusters;

if n_clusters == 0
    clusters = {};
    cluster_stats = [];
    p_values = [];
    significance_map = false(n_time, n_freq);
    return;
end

% Store clusters and compute their statistics
clusters = [pos_clusters.PixelIdxList, neg_clusters.PixelIdxList];
cluster_stats = zeros(1, n_clusters);

% Compute original cluster statistics
for i = 1:n_clusters
    cluster_stats(i) = sum(t_map(clusters{i}));
end

% Step 3: Generate random sign flips for all permutations at once
% Create [n_time x n_freq x n_sites x n_perms] random sign matrix
rand_signs = 2 * (rand(n_time, n_freq, n_sites, n_perms) > 0.5) - 1;

% Initialize arrays for null distribution
null_max_stats = zeros(1, n_perms);
null_min_stats = zeros(1, n_perms);

% Reshape diff_data for broadcasting
diff_data_expanded = repmat(diff_data, [1, 1, 1, n_perms]);

% Perform sign flipping for all permutations at once
perm_diffs = diff_data_expanded .* rand_signs;

% Compute t-statistics for all permutations efficiently
perm_means = mean(perm_diffs, 3);
perm_stds = std(perm_diffs, 0, 3);
perm_t_maps = perm_means ./ (perm_stds / sqrt(n_sites) + eps);

% Process each permutation's t-map
for p = 1:n_perms
    curr_t_map = perm_t_maps(:,:,1,p);
    
    % Find clusters in permuted data
    perm_pos = bwconncomp(curr_t_map > t_thresh_pos, 8);
    perm_neg = bwconncomp(curr_t_map < t_thresh_neg, 8);
    
    % Compute maximum statistics for positive clusters
    if perm_pos.NumObjects > 0
        pos_stats = arrayfun(@(idx) sum(curr_t_map(perm_pos.PixelIdxList{idx})), ...
            1:perm_pos.NumObjects);
        null_max_stats(p) = max(pos_stats);
    end
    
    % Compute minimum statistics for negative clusters
    if perm_neg.NumObjects > 0
        neg_stats = arrayfun(@(idx) sum(curr_t_map(perm_neg.PixelIdxList{idx})), ...
            1:perm_neg.NumObjects);
        null_min_stats(p) = min(neg_stats);
    end
end

% Compute p-values using vectorized operations
p_values = zeros(1, n_clusters);
% For positive clusters
for i = 1:n_pos_clusters
    p_values(i) = mean(null_max_stats >= cluster_stats(i));
end

% For negative clusters
for i = (n_pos_clusters+1):n_clusters
    p_values(i) = mean(null_min_stats <= cluster_stats(i));
end

% Create significance map
significance_map = false(n_time, n_freq);
for i = 1:n_clusters
    if p_values(i) < alpha
        significance_map(clusters{i}) = true;
    end
end


function plotRegionBoundaries(matrix)
% Get matrix dimensions
[rows, cols] = size(matrix);

% Create figure and display binary matrix
% figure;
% imagesc(matrix);
% colormap([1 1 1; 0 0 1]); % White background, blue regions
% axis equal tight;
hold on;

% Create extended matrix with padding to help detect edges
padded = zeros(rows+2, cols+2);
padded(2:end-1, 2:end-1) = matrix;

% Initialize arrays to store line segments
x = [];
y = [];

% Scan for horizontal edges
for i = 1:rows
    for j = 1:cols
        if matrix(i,j) == 1
            % Check top edge
            if i == 1 || matrix(i-1,j) == 0
                x = [x, j-0.5, j+0.5, NaN];
                y = [y, i-0.5, i-0.5, NaN];
            end
            % Check bottom edge
            if i == rows || matrix(i+1,j) == 0
                x = [x, j-0.5, j+0.5, NaN];
                y = [y, i+0.5, i+0.5, NaN];
            end
        end
    end
end

% Scan for vertical edges
for j = 1:cols
    for i = 1:rows
        if matrix(i,j) == 1
            % Check left edge
            if j == 1 || matrix(i,j-1) == 0
                x = [x, j-0.5, j-0.5, NaN];
                y = [y, i-0.5, i+0.5, NaN];
            end
            % Check right edge
            if j == cols || matrix(i,j+1) == 0
                x = [x, j+0.5, j+0.5, NaN];
                y = [y, i-0.5, i+0.5, NaN];
            end
        end
    end
end

% Plot all edges at once
plot(x, y, 'k', 'LineWidth', 2);

% Add title and adjust appearance
title('Binary Regions with Boundaries');
grid off;




